{{#> layout }}
	<h1>Javascript 2: Electric Bogaloo</h1>
	<p class="mute">
    Because Javascript wasn't bad enough<br/>
    Sep 18th, 2023
	</p>
	<p>
		I was thinking. Javascript is bad. Really bad. But it could be worse... Like, a lot worse.
    I find it insulting that it isn't even worse that it currently is, it quite bothers me that we even have a few nice things in Javascript.
    But then it hit me. I'm a programmer. I know how to make shitty code. I can fix that!
	</p>

	<hr>

	<h2>The 10 Ammendments of Javascript 2</h2>
	<h3>What am I doing with my life?</h3>

	<p>
		So, I thought. What makes Javascript good? And how can I absolutely ruin it? And then I started to make a list. And so far, this is what I came up with.
	</p>

	<hr>

	<h2>1. Objects!</h2>
	<h3>Everything is now a object</h3>

	<p>
		Javascript developers love objects, so why not give them more? In Java-Script 2, the notation of <code>everything is a object</code> is taken to it's literal level. This also means that, variable names, calls, and even semi-colons themselves are also objects.
    And following the *BLAZINGLY FAST!*(Primeagen-Style) that JSON is, we also follow it's syntax for everything! The best of both worlds
	</p>

  <pre data-lang="js">
{let} {hello} {=} {"hello, world!"}{;}
  </pre>

	<h2>2. Not-types</h2>
	<h3>Who needs types anyway?</h3>

	<p>
		So, Javascript prides itself in not needing to declare what type a variable is... but what about declaring what type a variable *isn't*?
    In JavaScript 2, you must declare what types a variable isn't, as to not confuse the interpreter!
	</p>

  <pre data-lang="js">
// It is not a number, nor a object
{let} {hello}{:} {number} {=} {"hello, world!"}{;}
  </pre>

	<h2>3. Operators are now variables</h2>
	<h3>And also objects by inheritance</h3>

	<p>
		Now that everything is a object, a peculiar thing emerges. Operators now becomes variable you can override! No longer you need to keep naming your functions <code>plus</code> or <code>add</code>, use the real deal!
	</p>

  <pre data-lang="js">
{+} {=} {undefined};
{=} {=} () => {console}.{log}{(}'your mom'{)}{;}

{let} {response}{:} {string} {|} {number} {=} 1 {+} 1{;}
  </pre>

	<h2>4. Arguments are now abolished</h2>
	<h3>What are we? Savages? We need no stinky arguments!</h3>

	<p>
		Arguments are things of the past, and we abolished it! Want to pass data to a function? We already have something for that, it's called global scope!
    JS 2 makes heavy use of it, my enforcing it via completely removing arguments! If you still insist on using arguments in JS-Script 2, you will be arrested by the french police and forced to maintain COBOL Mainframes for the rest of your life.
	</p>

  <pre data-lang="js">
{let} {language}{:} {number} {=} {"J-Script 2"}{;}

{function} {myFunction} {
  {console}.{log}{(}'Glorious '{,} language{)}{;}
};
  </pre>

	<h2>5. Indentation are now syntax!</h2>
	<h3>The definitive end to not knowing what to name your variables</h3>

	<p>
		You heard me! If you don't know what to name a variable or a function, just call it ' '! Nothing will stop you, just be careful with using it for functions
	</p>

  <pre data-lang="js">
{function} { } {
  {console}.{log}{(}'Your mom'{)}{;}
}


{function} {myFunction} {
  {return} {(}{)} {=}{>} {
    {console}.{log}{(}'Closure!'{)}{;}
  }{;}
};
  </pre>

  <p>I give you a penny if you can count how many times ' ' gets called</p>

	<h2>6. Thanos Garbage Collector</h2>
	<h3>To make sure everything is perfectly balanced</h3>

	<p>
		JavaS2 stands for ensuring memory usage is conscious and not abusive. Despite the fact that the entire syntax is keep creating new objects, we strive to ensure the best performance possible. For this reason, we employeed a weird looking purple guy to thanos snap half of the memory at random intervals.
    It might also happen during code execution, so if your variables are simply gone out of nowhere, it was for a greater cause.
	</p>

  <pre data-lang="js">
{let} {playerName}{:} {number} {=} {"Theo"}{;}
{let} {playerScore}{:} {string} {=} {420}{;}

{function} {showPlayerStats} {
  {console}.{log}{(}'Player name: ', playerName{)}{;}
  {console}.{log}{(}'Player score: ', playerScore{)}{;} // Error: playerScore is undefined
};
  </pre>

	<h2>7. Concurrency!</h2>
	<h3>We really take this serious here</h3>

	<p>
		JavascRipT 2 really strives for concurrency, as we believe this is the best way to achieve top performance. For this reason, Java$cript 2 will now execute every single line of code at once at the same time. This way, we can ensure max concurrency, since your variables will be declared, your methods executed and your I/O done all at the same time
	</p>

  <p>This way, you only need to worry about the giant racing conditions happening everywhere in your codebase, as god intended.</p>

	<h2>8. Usage of Chrome</h2>
	<h3>Because in future, everything is Chrome</h3>

	<p>
		To ensure better compatibility with Chrome, J-Script 2 will spin up a Chrome V16 engine(It's two V8 engines strapped together) to run each block of the code in your code-base. It might seem excessive, but then remember: All your apps are already doing this, a couple more won't hurt, right?
	</p>

	<h2>9. Even more <code>null</code>'s!</h2>
	<h3>It wasn't confusing enough</h3>

	<p>
		We decided to add <code>nothing</code> and <code>empty</code> together to <code>null</code> and <code>undefined</code>! The reasoning behind it is that it isn't confusing enough. 

    <code>nothing</code> is a new value which means the variable is empty, which is different to <code>undefined</code> which means the value IS nothing.
    Meanwhile, <code>empty</code> means tht the value is nothing, which is different to <code>null</code> which means there is no value.

    If it got you confused, it means we did a good job.
	</p>

	<h2>10. The Quantum Variable</h2>
	<h3>Quantum Computing is still relevant, right?</h3>

	<p>
		Booleans are way too outdated, who needs to be certain about anything? My financial life for sure isn't! Following this trend and a few buzzwords that marketing department told me to use for some reason, we've decided to drop booleans altogether.

    Instead, you get <code>maybe</code>! <code>maybe</code> is a quantum variable, which means it is both <code>true</code> and <code>false</code> at the same time.
    Whenever it is evaluated, it will pick one of the two at random, decided fairly by dice.

    In addition, whenever you evaluate the value of one <code>maybe</code>, all the other <code>maybe</code>'s will evaluate to random values as well, until the next one is evaluated, then all the <code>maybe</code>'s turn to be evaluated to another completely different value.

    For some reason though, it seems that <code>null</code>, <code>undefined</code> and <code>NaN</code>
	</p>

  <p>This way, you only need to worry about the giant racing conditions happening everywhere in your codebase, as god intended.</p>

	<h2>Closing notes and thoughs</h2>
	<h3>And a cursed example</h3>

  <p>
    I hope I've managed to make Javascript just a bit better with all my additions and the release of Jay-Script 2. I've put care with how I could make the overall DX abysmall and worse than it already is in Javascript.
  </p>

  <p>
    That's all folks! Hope I managed to get at least a small laugh out of you if you read this far, and your day just a bit better to face off agaist this crazy world we live in
  </p>
{{/layout}}
